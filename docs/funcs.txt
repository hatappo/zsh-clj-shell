
;; clojure.core
*
*'
*1
*2
*3
*assert*
*clojure-version*
*command-line-args*
*compile-files*
*compile-path*
*compiler-options*
*data-readers*
*default-data-reader-fn*
*e
*err*
*file*
*flush-on-newline*
*in*
*math-context*
*ns*
*out*
*print-dup*
*print-length*
*print-level*
*print-meta*
*print-namespace-maps*
*print-readably*
*read-eval*
*reader-resolver*
*repl*
*source-path*
*suppress-read*
*unchecked-math*
*warn-on-reflection*
+
+'
-
-'
->
->>
->Eduction
-add-loaded-lib
-locking-impl
-new-dynamic-var
-new-var
-reified-methods
-run-in-transaction
-with-precision
..
/
<
<=
=
==
>
>=
NaN?
PrintWriter-on
StackTraceElement->vec
Throwable->map
abs
aclone
add-tap
add-watch
agent
agent-error
aget
alength
alias
all-ns
alter
alter-meta!
alter-var-root
amap
ancestors
and
any?
apply
areduce
array-map
as->
aset
aset-boolean
aset-byte
aset-char
aset-double
aset-float
aset-int
aset-long
aset-short
assert
assoc
assoc!
assoc-in
associative?
atom
await
await-for
bean
bigdec
bigint
biginteger
binding
binding-conveyor-fn
bit-and
bit-and-not
bit-clear
bit-flip
bit-not
bit-or
bit-set
bit-shift-left
bit-shift-right
bit-test
bit-xor
boolean
boolean-array
boolean?
booleans
bound-fn
bound-fn*
bound?
bounded-count
butlast
byte
byte-array
bytes
bytes?
case
cat
char
char-array
char-escape-string
char-name-string
char?
chars
chunk
chunk-append
chunk-buffer
chunk-cons
chunk-first
chunk-next
chunk-rest
chunked-seq?
class
class?
clojure-version
coll?
comment
commute
comp
comparator
compare
compare-and-set!
complement
completing
concat
cond
cond->
cond->>
condp
conj
conj!
cons
constantly
contains?
count
counted?
create-ns
cycle
dec
dec'
decimal?
declare
dedupe
default-data-readers
defmacro
defmethod
defmulti
defn
defn-
defonce
defprotocol
defrecord
deftype
delay
delay?
deliver
denominator
deref
derive
descendants
destructure
disj
disj!
dissoc
dissoc!
distinct
distinct?
doall
dorun
doseq
dosync
dotimes
doto
double
double-array
double?
doubles
drop
drop-last
drop-while
eduction
empty
empty?
ensure
ensure-reduced
enumeration-seq
error-handler
error-mode
eval
even?
every-pred
every?
ex-cause
ex-data
ex-info
ex-message
extend
extend-protocol
extend-type
extends?
false?
ffirst
file-seq
filter
filterv
find
find-ns
find-var
first
flatten
float
float-array
float?
floats
flush
fn
fn?
fnext
fnil
for
force
format
frequencies
future
future-call
future-cancel
future-cancelled?
future-done?
future?
gensym
get
get-in
get-method
get-thread-binding-frame-impl
get-thread-bindings
get-validator
global-hierarchy
group-by
halt-when
has-root-impl
hash
hash-combine
hash-map
hash-ordered-coll
hash-set
hash-unordered-coll
ident?
identical?
identity
if-let
if-not
if-some
ifn?
in-ns
inc
inc'
indexed?
infinite?
inst-ms
inst?
instance?
int
int-array
int?
integer?
interleave
intern
interpose
into
into-array
ints
isa?
iterate
iteration
iterator-seq
juxt
keep
keep-indexed
key
keys
keyword
keyword?
last
lazy-cat
lazy-seq
let
letfn
line-seq
list
list*
list?
load
load-file
load-reader
load-string
loaded-libs
locking
long
long-array
longs
loop
macroexpand
macroexpand-1
make-array
make-hierarchy
map
map-entry?
map-indexed
map?
mapcat
mapv
max
max-key
memfn
memoize
merge
merge-with
meta
methods
min
min-key
mod
multi-fn-add-method-impl
multi-fn-impl
multi-fn?-impl
munge
name
namespace
namespace-munge
nat-int?
neg-int?
neg?
newline
next
nfirst
nil?
nnext
not
not-any?
not-empty
not-every?
not=
ns
ns-aliases
ns-imports
ns-interns
ns-map
ns-name
ns-publics
ns-refers
ns-resolve
ns-unalias
ns-unmap
nth
nthnext
nthrest
num
number?
numerator
object-array
odd?
or
parents
parse-boolean
parse-double
parse-long
parse-uuid
partial
partition
partition-all
partition-by
partitionv
partitionv-all
peek
persistent!
pmap
pop
pop!
pop-thread-bindings
pos-int?
pos?
pr
pr-str
prefer-method
prefers
print
print-dup
print-method
print-simple
print-str
printf
println
println-str
prn
prn-str
promise
protocol-type-impl
proxy
proxy*
push-thread-bindings
qualified-ident?
qualified-keyword?
qualified-symbol?
quot
rand
rand-int
rand-nth
random-sample
random-uuid
range
ratio?
rational?
rationalize
re-find
re-groups
re-matcher
re-matches
re-pattern
re-seq
read
read+string
read-line
read-string
reader-conditional
reader-conditional?
realized?
record?
reduce
reduce-kv
reduced
reduced?
reductions
ref
ref-set
refer
refer-clojure
reify
reify*
release-pending-sends
rem
remove
remove-all-methods
remove-method
remove-ns
remove-tap
remove-watch
repeat
repeatedly
replace
replicate
require
requiring-resolve
reset!
reset-meta!
reset-thread-binding-frame-impl
reset-vals!
resolve
rest
restart-agent
reverse
reversible?
rseq
rsubseq
run!
satisfies?
second
select-keys
send
send-off
send-via
seq
seq-to-map-for-destructuring
seq?
seqable?
seque
sequence
sequential?
set
set-agent-send-executor!
set-agent-send-off-executor!
set-error-handler!
set-error-mode!
set-validator!
set?
short
short-array
shorts
shuffle
shutdown-agents
simple-ident?
simple-keyword?
simple-symbol?
slurp
some
some->
some->>
some-fn
some?
sort
sort-by
sorted-map
sorted-map-by
sorted-set
sorted-set-by
sorted?
special-symbol?
spit
split-at
split-with
splitv-at
str
stream-into!
stream-reduce!
stream-seq!
stream-transduce!
string?
subs
subseq
subvec
supers
swap!
swap-vals!
symbol
symbol?
sync
system-time
tagged-literal
tagged-literal?
take
take-last
take-nth
take-while
tap>
test
the-ns
thread-bound?
time
to-array
to-array-2d
trampoline
transduce
transient
tree-seq
true?
type
unchecked-add
unchecked-add-int
unchecked-byte
unchecked-char
unchecked-dec
unchecked-dec-int
unchecked-divide-int
unchecked-double
unchecked-float
unchecked-inc
unchecked-inc-int
unchecked-int
unchecked-long
unchecked-multiply
unchecked-multiply-int
unchecked-negate
unchecked-negate-int
unchecked-remainder-int
unchecked-short
unchecked-subtract
unchecked-subtract-int
underive
unquote
unreduced
unsigned-bit-shift-right
update
update-in
update-keys
update-vals
uri?
use
uuid?
val
vals
var-get
var-set
var?
vary-meta
vec
vector
vector?
volatile!
volatile?
vreset!
vswap!
when
when-first
when-let
when-not
when-some
while
with-bindings
with-bindings*
with-in-str
with-local-vars
with-meta
with-open
with-out-str
with-precision
with-redefs
with-redefs-fn
xml-seq
zero?
zipmap

;; clojure.core.protocols
Datafiable
IKVReduce
Navigable
datafy
nav

;; clojure.data
diff
equality-partition

;; clojure.datafy
datafy
nav

;; clojure.edn
read
read-string

;; clojure.math
E
IEEE-remainder
PI
acos
add-exact
asin
atan
atan2
cbrt
ceil
copy-sign
cos
cosh
decrement-exact
exp
expm1
floor
floor-div
floor-mod
get-exponent
hypot
increment-exact
log
log10
log1p
multiply-exact
negate-exact
next-after
next-down
next-up
pow
random
rint
round
scalb
signum
sin
sinh
sqrt
subtract-exact
tan
tanh
to-degrees
to-radians
ulp

;; clojure.java.browse
*open-url-script*
browse-url

;; clojure.java.io
Coercions
as-file
as-relative-path
as-url
copy
delete-file
file
input-stream
make-parents
output-stream
reader
resource
writer

;; clojure.java.shell
*sh-dir*
*sh-env*
sh
with-sh-dir
with-sh-env

;; clojure.main
demunge
main
repl
repl-caught
repl-requires
with-bindings
with-read-known

;; clojure.pprint
*print-miser-width*
*print-pprint-dispatch*
*print-right-margin*
cached-compile
cl-format
code-dispatch
execute-format
formatter-out
get-pretty-writer
init-navigator
pp
pprint
print-table
simple-dispatch
with-pprint-dispatch
write
write-out

;; clojure.set
difference
index
intersection
join
map-invert
project
rename
rename-keys
select
subset?
superset?
union

;; clojure.string
blank?
capitalize
ends-with?
escape
includes?
index-of
join
last-index-of
lower-case
re-quote-replacement
replace
replace-first
reverse
split
split-lines
starts-with?
trim
trim-newline
triml
trimr
upper-case

;; clojure.stacktrace
print-cause-trace
print-stack-trace
print-throwable
print-trace-element
root-cause

;; clojure.test
*initial-report-counters*
*load-tests*
*report-counters*
*stack-trace-depth*
*test-out*
*testing-contexts*
*testing-vars*
are
assert-any
assert-expr
assert-predicate
compose-fixtures
deftest
deftest-
do-report
function?
inc-report-counter
is
join-fixtures
report
run-all-tests
run-test
run-test-var
run-tests
set-test
successful?
test-all-vars
test-ns
test-var
test-vars
testing
testing-contexts-str
testing-vars-str
try-expr
use-fixtures
with-test
with-test-out

;; clojure.walk
keywordize-keys
macroexpand-all
postwalk
postwalk-demo
postwalk-replace
prewalk
prewalk-demo
prewalk-replace
stringify-keys
walk

;; clojure.zip
append-child
branch?
children
down
edit
end?
insert-child
insert-left
insert-right
left
leftmost
lefts
make-node
next
node
path
prev
remove
replace
right
rightmost
rights
root
seq-zip
up
vector-zip
xml-zip
zipper

;; babashka.cli
auto-coerce
coerce
dispatch
format-opts
format-table
merge-opts
number-char?
opts->table
pad
pad-cells
parse-args
parse-cmds
parse-keyword
parse-opts
spec->opts

;; babashka.classpath
add-classpath
get-classpath
split-classpath

;; babashka.deps
add-deps
clojure
merge-defaults
merge-deps

;; babashka.fs
absolute?
absolutize
canonicalize
components
copy
copy-tree
create-dir
create-dirs
create-file
create-link
create-sym-link
create-temp-dir
create-temp-file
creation-time
cwd
delete
delete-if-exists
delete-on-exit
delete-tree
directory?
ends-with?
exec-paths
executable?
exists?
expand-home
extension
file
file-name
file-separator
file-time->instant
file-time->millis
get-attribute
glob
gunzip
gzip
hidden?
home
instant->file-time
last-modified-time
list-dir
list-dirs
match
millis->file-time
modified-since
move
normalize
owner
parent
path
path-separator
posix->str
posix-file-permissions
read-all-bytes
read-all-lines
read-attributes
read-attributes*
read-link
readable?
real-path
regular-file?
relative?
relativize
root
same-file?
set-attribute
set-creation-time
set-last-modified-time
set-posix-file-permissions
size
split-ext
split-paths
starts-with?
str->posix
strip-ext
sym-link?
temp-dir
unixify
unzip
update-file
walk-file-tree
which
which-all
windows?
with-temp-dir
writable?
write-bytes
write-lines
xdg-cache-home
xdg-config-home
xdg-data-home
xdg-state-home
zip

;; babashka.http-client
->Authenticator
->CookieHandler
->Executor
->ProxySelector
->SSLContext
->SSLParameters
client
default-client-opts
delete
get
head
patch
post
put
request

;; babashka.process
$
*defaults*
alive?
check
destroy
destroy-tree
exec
parse-args
pb
pipeline
process
process*
sh
shell
start
tokenize

;; babashka.signal
pipe-signal-received?

;; babashka.tasks
*task*
-chan?
-err-thread
-wait
clojure
current-state
current-task
exec
run
shell

;; babashka.wait
wait-for-path
wait-for-port

;; bencode.core
read-bencode
write-bencode

;; cheshire.core
create-pretty-printer
decode
default-pretty-print-options
encode
encode-stream
generate-stream
generate-string
parse-stream
parse-stream-strict
parse-string
parse-string-strict
parsed-seq

;; clojure.core.async
-vthread-call
<!
<!!
>!
>!!
admix
alt!
alt!!
alts!
alts!!
buffer
chan
close!
do-alt
do-alts
dropping-buffer
filter<
filter>
go
go-loop
into
io-thread
map
map<
map>
mapcat<
mapcat>
merge
mix
mult
offer!
onto-chan
onto-chan!
onto-chan!!
partition
partition-by
pipe
pipeline
pipeline-async
pipeline-blocking
poll!
promise-chan
pub
put!
reduce
remove<
remove>
sliding-buffer
solo-mode
split
sub
take
take!
tap
thread
thread-call
timeout
to-chan
to-chan!
to-chan!!
toggle
transduce
unblocking-buffer?
unique
unmix
unmix-all
unsub
unsub-all
untap
untap-all

;; clojure.data.csv
read-csv
write-csv

;; clojure.data.xml
aggregate-xmlns
alias-uri
as-qname
cdata
element
element*
element-nss
element?
emit
emit-str
event-seq
find-xmlns
indent
indent-str
parse
parse-qname
parse-str
print-uri-file-command!
qname
qname-local
qname-uri
sexp-as-element
sexps-as-fragment
symbol-uri
uri-file
uri-symbol
xml-comment

;; clojure.tools.cli
format-lines
get-default-options
make-summary-part
parse-opts
summarize

;; clj-yaml.core
generate-stream
generate-string
mark
parse-stream
parse-string
unmark

;; cognitect.transit
default-write-handlers
read
read-handler
read-handler-map
reader
tagged-value
write
write-handler
write-handler-map
write-meta
writer

;; org.httpkit.client
*default-client*
acl
copy
default-client
delete
get
head
lock
make-client
make-ssl-engine
max-body-filter
move
options
patch
post
propfind
proppatch
put
query-string
report
request
unlock
url-encode

;; org.httpkit.server
as-channel
close
on-close
run-server
sec-websocket-accept
send!
send-checked-websocket-handshake!
send-websocket-handshake!
server-port
server-status
server-stop!
websocket-handshake-check
with-channel

;; clojure.core.match
backtrack
defpred
match
val-at*

;; hiccup.core
html

;; hiccup2.core
html
raw

;; clojure.test.check
quick-check

;; clojure.test.check.generators
->Generator
any
any-equatable
any-printable
any-printable-equatable
big-ratio
bind
boolean
byte
bytes
call-gen
char
char-alpha
char-alpha-numeric
char-alphanumeric
char-ascii
choose
container-type
double
double*
elements
fmap
frequency
gen-bind
gen-fmap
gen-pure
generate
generator?
hash-map
int
keyword
keyword-ns
large-integer
large-integer*
lazy-random-states
let
list
list-distinct
list-distinct-by
make-size-range-seq
map
map->Generator
nat
neg-int
no-shrink
not-empty
one-of
pos-int
ratio
recursive-gen
resize
return
s-neg-int
s-pos-int
sample
sample-seq
scale
set
shrink-2
shuffle
simple-type
simple-type-equatable
simple-type-printable
simple-type-printable-equatable
size-bounded-bigint
sized
small-integer
sorted-set
string
string-alpha-numeric
string-alphanumeric
string-ascii
such-that
symbol
symbol-ns
tuple
uuid
vector
vector-distinct
vector-distinct-by

;; clojure.test.check.properties
->ErrorResult
for-all
for-all*
map->ErrorResult

;; rewrite-clj.parser
parse-file
parse-file-all
parse-string
parse-string-all

;; rewrite-clj.node
child-sexprs
children
coerce
comma-node
comma-separated
comma?
comment-node
comment?
deref-node
eval-node
fn-node
forms-node
inner?
integer-node
keyword-node
keyword-node?
leader-length
length
line-separated
linebreak?
list-node
map-context-apply
map-context-clear
map-node
map-qualifier-node
meta-node
namespaced-map-node
newline-node
newlines
node?
printable-only?
quote-node
raw-meta-node
reader-macro-node
regex-node
replace-children
set-node
sexpr
sexpr-able?
sexprs
spaces
string
string-node
symbol-node?
syntax-quote-node
tag
token-node
uneval-node
unquote-node
unquote-splicing-node
value
var-node
vector-node
whitespace-node
whitespace-nodes
whitespace-or-comment?
whitespace?

;; rewrite-clj.zip
->root-string
->string
append-child
append-child*
append-newline
append-space
assoc
child-sexprs
down
down*
edit
edit*
edit->
edit->>
edit-node
edn
edn*
end?
find
find-depth-first
find-last-by-pos
find-next
find-next-depth-first
find-next-tag
find-next-token
find-next-value
find-tag
find-tag-by-pos
find-token
find-value
get
insert-child
insert-child*
insert-left
insert-left*
insert-newline-left
insert-newline-right
insert-right
insert-right*
insert-space-left
insert-space-right
left
left*
leftmost
leftmost*
leftmost?
length
linebreak?
list?
map
map-keys
map-vals
map?
namespaced-map?
next
next*
node
of-file
of-file*
of-node
of-node*
of-string
of-string*
position
position-span
postwalk
prefix
prepend-newline
prepend-space
prev
prev*
prewalk
print
print-root
reapply-context
remove
remove*
remove-preserve-newline
replace
replace*
right
right*
rightmost
rightmost*
rightmost?
root
root-string
seq?
set?
sexpr
sexpr-able?
skip
skip-whitespace
skip-whitespace-left
splice
string
subedit->
subedit->>
subedit-node
subzip
suffix
tag
up
up*
value
vector?
whitespace-or-comment?
whitespace?

;; rewrite-clj.paredit
barf-backward
barf-forward
join
kill
kill-at-pos
kill-one-at-pos
move-to-prev
raise
slurp-backward
slurp-backward-fully
slurp-backward-fully-into
slurp-backward-into
slurp-forward
slurp-forward-fully
slurp-forward-fully-into
slurp-forward-into
splice
splice-killing-backward
splice-killing-forward
split
split-at-pos
wrap-around
wrap-fully-forward-slurp

;; selmer.parser
<<
add-filter!
add-node
add-tag!
append-node
cache-off!
cache-on!
cache?
clear-cache!
ensure-list
env-map
expr-tag
filter-tag
known-variable-paths
known-variables
parse
parse*
parse-file
parse-input
parse-str
parse-tag
remove-tag!
render
render-file
render-template
resolve-arg
resolve-var-from-kw
set-closing-tags!
set-resource-path!
skip-short-comment-tag
tag-content
templates
update-tag
update-tags

;; clojure.tools.logging
*logger-factory*
debug
debugf
error
errorf
info
infof
log
log*
logf
logp
trace
tracef
warn
warnf

;; taoensso.timbre
*config*
-log!
-log-and-rethrow-errors
-spy
color-str
debug
debugf
error
errorf
info
infof
log!
may-log?
merge-config!
println-appender
set-config!
set-level!
set-min-level!
set-ns-min-level
set-ns-min-level!
spit-appender
spy
swap-config!
trace
tracef
warn
warnf
with-level

;; edamame.core
continue
get-column-number
get-line-number
iobj?
normalize-opts
parse-next
parse-next+string
parse-ns-form
parse-string
parse-string-all
reader
source-reader

;; nextjournal.markdown
->hiccup
default-hiccup-renderers
empty-doc
into-hiccup
node->text
parse
parse*
table-alignment
toc->hiccup
